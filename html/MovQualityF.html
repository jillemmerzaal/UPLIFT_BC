
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>movement quality functional activity</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-10-17"><meta name="DC.source" content="MovQualityF.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>movement quality functional activity</h1><!--introduction--><pre>TO DO
selecteer de "rust fases" voor en na de gesegmenteerde herhalingen en
verwijder deze. Plak daarna de signalen weer aan elkaar.</pre><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">1) Input</a></li><li><a href="#5">2) Load data</a></li><li><a href="#7">2.1) Load xsens data</a></li><li><a href="#8">3) Event detection</a></li><li><a href="#10">3.1) excessive "rest" periods</a></li><li><a href="#12">4) table stetup and calculati9on of the movement quality parameters</a></li><li><a href="#13">4.1) Lyapunov exponent matlab function</a></li><li><a href="#15">4.2) LDLJ_A</a></li><li><a href="#17">4.3) SPARC --&gt; SPECTRAL ARC LENGTH ON RAW ANGULAR VELOCITY</a></li><li><a href="#18">4.4) sample entropy Jill --&gt; TO defines tollerance</a></li><li><a href="#20">4.5) Autocorrelation</a></li><li><a href="#21">4.6) Movement speed based on the repetitions</a></li><li><a href="#22">4.7) RMS</a></li><li><a href="#23">5) Save raw acc and avel data to struct</a></li><li><a href="#24">6) Save movement quality to table</a></li><li><a href="#26">7) everything in one gigantic table.</a></li></ul></div><pre>I need to run this file using publish en use that as a help function.
Which means I need to explain everyting in more detail. When the code is
finished :)</pre><pre>BC_014 T2 --&gt; heeft veel last. Dus misschien interessant om die data te
bekijken.</pre><pre class="codeinput">clearvars; clc; close <span class="string">all</span>;
</pre><h2 id="3">1) Input</h2><pre>Change the U-number and path to match where the data is located. Change
the timepoint that you want to analyse</pre><pre class="codeinput">cd(<span class="string">"C:\Users\u0117545\Documents\GitHub\ULIFT_BC"</span>)
addpath(<span class="string">"C:\Users\u0117545\OneDrive - KU Leuven\2.Dataprocessing\Matlab\addons"</span>)

Timepoint   = <span class="string">'T0'</span>;
movement    = <span class="string">"F"</span>;
path.root   = <span class="string">'C:\Users\u0117545\KU Leuven\An De Groef - DATA'</span>;
path.out    = fullfile(path.root,<span class="string">'Output'</span>,<span class="string">'Database_MovQual.mat'</span>);
fs          = 60;
plot_or_not = 1;

Affected_table = readtable(fullfile(path.root,<span class="string">"Aangedane zijde.xlsx"</span>));
</pre><h2 id="5">2) Load data</h2><pre class="codeinput"><span class="keyword">for</span> subj = (6)<span class="comment">% 9 10 11 12 14 16 17 19 21)  % 1:21%21 (8 9 10 11 12 14 16 17 19 21) == proefpersonen zonder "rust" data.</span>
    <span class="keyword">if</span> subj &lt; 10
        subj_name   = [<span class="string">'BC_00'</span> num2str(subj)];
    <span class="keyword">elseif</span> subj &lt; 100
        subj_name   = [<span class="string">'BC_0'</span> num2str(subj)];
    <span class="keyword">else</span>
        subj_name   = [<span class="string">'BC_'</span>, num2str(subj)];
    <span class="keyword">end</span>

    affected = Affected_table(strcmp(Affected_table.ppID, subj_name), <span class="string">"involved"</span>);


    disp(<span class="string">' '</span>)
    disp([<span class="string">'Processing '</span> subj_name <span class="string">': '</span> Timepoint <span class="string">'.....'</span>])

    path.subj   = fullfile(path.root, subj_name, <span class="string">'Xsens'</span>, Timepoint, <span class="string">'Reproces'</span>);
    check_subj  = exist(path.subj, <span class="string">"dir"</span>);

    <span class="keyword">if</span> check_subj == 7
        <span class="comment">%initialize counters</span>
        counterR        = 0;
        counterR_SSS    = 0;
        counterL        = 0;
        counterL_SSS    = 0;

        content = dir(path.subj);
        nfiles = size(content,1);

        <span class="comment">% Start loop through ULIFT files per subject</span>
        <span class="keyword">for</span> file = 1:nfiles
            <span class="keyword">if</span> contains(content(file).name, movement) &amp;&amp; contains(content(file).name, <span class="string">'.mvnx'</span>) &amp;&amp; ~contains(content(file).name, <span class="string">'AF'</span>) &amp;&amp; ~contains(content(file).name, <span class="string">'ULIFT'</span>)
                file_ik = fullfile(path.subj, content(file).name);

                [~,name, ~] = fileparts(content(file).name);
                [fileName] = regexprep(name, <span class="string">'-'</span>, <span class="string">'_'</span>);

                d = strfind(name,<span class="string">'_'</span>);
                arm = content(file).name(d+1);

                <span class="keyword">if</span> ~isempty(Affected_table{strcmp(Affected_table.ppID, subj_name), <span class="string">"involved"</span>})
</pre><pre class="codeinput">                    <span class="keyword">if</span> strcmp(arm, <span class="string">'L'</span>)
                        sensorno    = 10;
                        segmentno   = 14;
                        jointno     = 12;

                        <span class="keyword">if</span> strcmp(Affected_table{strcmp(Affected_table.ppID, subj_name), <span class="string">"involved"</span>}, <span class="string">'L'</span>)
                            side = <span class="string">'affected'</span>;
                        <span class="keyword">else</span>
                            side = <span class="string">'unaffected'</span>;

                        <span class="keyword">end</span>

                    <span class="keyword">elseif</span> strcmp(arm, <span class="string">'R'</span>)
                        sensorno    = 6;
                        segmentno   = 10;
                        jointno     = 8;

                        <span class="keyword">if</span> strcmp(Affected_table{strcmp(Affected_table.ppID, subj_name), <span class="string">"involved"</span>}, <span class="string">'R'</span>)
                            side = <span class="string">'affected'</span>;
                        <span class="keyword">else</span>
                            side = <span class="string">'unaffected'</span>;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>

                    disp([<span class="string">'     '</span> <span class="string">'Analysing: '</span> fileName <span class="string">'.....'</span>])
                    disp([<span class="string">'   '</span> <span class="string">'Arm of interst: '</span> arm <span class="string">'.....'</span>])
</pre><pre class="codeoutput">     Analysing: F_L_001.....
   Arm of interst: L.....
</pre><pre class="codeoutput">     Analysing: F_R_001.....
   Arm of interst: R.....
</pre><h2 id="7">2.1) Load xsens data</h2><p>Change the filename here to the name of the file you would like to import</p><pre class="codeinput">                    disp([<span class="string">'    '</span> content(file).name <span class="string">': read xsens file'</span>])
                    [sensorData, segmentData, jointData]= MVN(file_ik);

                    <span class="comment">% extract unflitered acceleration data</span>
                    x = sensorData(sensorno).sensorFreeAcceleration(:,1);
                    y = sensorData(sensorno).sensorFreeAcceleration(:,2);
                    z = sensorData(sensorno).sensorFreeAcceleration(:,3);
                    res = vecnorm(sensorData(sensorno).sensorFreeAcceleration,2,2);
                    acc = table(x, y, z, res); <span class="comment">% table of unfiltered acceleration data</span>
                    clear <span class="string">x</span> <span class="string">y</span> <span class="string">z</span> <span class="string">res</span>


                    <span class="comment">% extract unfiltered angular velocity data</span>
                    x = segmentData(segmentno).angularVelocity(:,1);
                    y = segmentData(segmentno).angularVelocity(:,2);
                    z = segmentData(segmentno).angularVelocity(:,3);
                    res = vecnorm(segmentData(segmentno).angularVelocity,2,2);

                    avel = table(x, y, z, res);
                    clear <span class="string">x</span> <span class="string">y</span> <span class="string">z</span> <span class="string">res</span>

                    <span class="comment">% extract unfiltered sement velocity data</span>
                    x = segmentData(segmentno).velocity(:,1);
                    y = segmentData(segmentno).velocity(:,2);
                    z = segmentData(segmentno).velocity(:,3);
                    res = vecnorm(segmentData(segmentno).velocity, 2, 2);

                    vel = table(x, y, z, res);
                    clear <span class="string">x</span> <span class="string">y</span> <span class="string">z</span> <span class="string">res</span>
</pre><pre class="codeoutput">    F_L-001.mvnx: read xsens file
Warning: Error updating Text.

 String scalar or character vector must have valid interpreter syntax:
Loading file C:\Users\u0117545\KU Leuven\An De Groef -
DATA\BC_006\Xsens\T0\Reproces\F_L-001.mvnx
 
</pre><pre class="codeoutput">    F_R-001.mvnx: read xsens file
Warning: Error updating Text.

 String scalar or character vector must have valid interpreter syntax:
Loading file C:\Users\u0117545\KU Leuven\An De Groef -
DATA\BC_006\Xsens\T0\Reproces\F_R-001.mvnx
 
</pre><h2 id="8">3) Event detection</h2><pre>Seperation of the different repetitions using
filtered velocity data. Filter properties: 4th
order Butterwoth filter at 2 Hz. Peak detection of local maxima and minima is
applied on the velocity vector.
Local minima-- vector approximates zero-- means a
change in direction. We use a priori knowledge that
the the first rep should start after a local
maximum. This to remove the first and last
initiation where the intentd of movement is
different.</pre><pre class="codeinput">                    disp([<span class="string">'    '</span> content(file).name <span class="string">': define seperate repetitions'</span>])

                    <span class="comment">%filtered velocity data for segmentation</span>
                    fc = 2;  <span class="comment">%cutoff freq</span>
                    fs = 60; <span class="comment">%sample freq</span>
                    [b,a] = butter(4, fc/(fs/2));

                    velocity2 = filtfilt(b,a, segmentData(segmentno).velocity);
                    velocityX = velocity2(:,1);
                    velocityY = velocity2(:,2);
                    velocityZ = velocity2(:,3);
                    velocityVec = vecnorm(velocity2, 2,2);

                    vel_filtered     = table(velocityX, velocityY, velocityZ, velocityVec);

                    clear <span class="string">velocity2</span> <span class="string">velocityX</span> <span class="string">velocityY</span> <span class="string">velocityZ</span> <span class="string">velocityVec</span>

                    [peakLocMax, peakMagMax] =  peakfinder(vel_filtered.velocityVec, [],[],1, false);
                    [peakLocMin, peakMagMin] =  peakfinder(vel_filtered.velocityVec, [],[],-1, false);

                    <span class="keyword">if</span> strcmp(side, <span class="string">'affected'</span>)
                        <span class="keyword">if</span> peakLocMin(1) - peakLocMax(1) &lt; 0
                            startpeak = 2;
                            reps = peakLocMin(startpeak:2:end);
                        <span class="keyword">elseif</span> peakLocMin(1) - peakLocMax(1) &gt; 0
                            startpeak = 1;
                            reps = peakLocMin(startpeak:2:end);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>

                    <span class="keyword">if</span> peakLocMin(1) - peakLocMax(1) &lt; 0
                        reps = peakLocMin(2:2:end);
                    <span class="keyword">elseif</span> peakLocMin(1) - peakLocMax(1) &gt; 0
                        reps = peakLocMin(1:2:end);
                    <span class="keyword">end</span>
</pre><pre class="codeoutput">    F_L-001.mvnx: define seperate repetitions
</pre><pre class="codeoutput">    F_R-001.mvnx: define seperate repetitions
</pre><h2 id="10">3.1) excessive "rest" periods</h2><pre>Extensive rest periods in the data influence the
calculation of the movement qality parameters.
Therefore we need to remove those rest periods and
only retain the moving data.</pre><pre>THE DATA IS COMPARED TO A REFERENCE SIGNAL.
IN THIS CASE A SIMPLE INVERTED SINE WAVE in case of
the velocity in z-rection
We use the rationalle that we only want to calculate
the movement quality parameters on movement data.
Therefore, we are strickt in our trimming process,
and use the velocity data in Z-direction in stead of the vector.</pre><pre class="codeinput">                    t=0:0.001:1;
                    f=1;
                    x=sin(2*pi*f*t)*-1;

                    <span class="keyword">for</span> idx = 1:length(reps)-1
                        [istart.Z(idx),istop.Z(idx),dist.Z(idx)] = findsignal(vel_filtered.velocityZ(reps(idx):reps(idx+1)), x,<span class="string">'TimeAlignment'</span>,<span class="string">'dtw'</span>,<span class="string">'Metric'</span>,<span class="string">'absolute'</span>);
                    <span class="keyword">end</span>

                    <span class="comment">%plot individual velocity vectors</span>
                    <span class="keyword">if</span> plot_or_not
                        <span class="keyword">if</span> strcmp(side, <span class="string">'affected'</span>)
                            nexttile
                            <span class="keyword">for</span> idx = 1:length(reps)-1
                                plot(vel.z(reps(idx):reps(idx+1)))
                                hold <span class="string">on</span>;
                                hline(0)
                            <span class="keyword">end</span>
                            plottitle = {[subj_name, <span class="string">' individual reps'</span>]};
                            title(plottitle)

                            nexttile
                            <span class="keyword">for</span> idx = 1:length(reps)-1
                                temp_istart = reps(idx) + istart.Z(idx);
                                temp_istop = reps(idx) + istop.Z(idx);
                                temp_df.rep{:,idx} = vel.z(temp_istart:temp_istop);


                                plot(temp_df.rep{:,idx}); hold <span class="string">on</span>
                            <span class="keyword">end</span>
                            plottitle = {[subj_name, <span class="string">' individual reps trimmed'</span>]};
                            title(plottitle)
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>


                    <span class="comment">% trim the repetitions and save them in a temporary</span>
                    <span class="comment">% variable.</span>
                    <span class="keyword">for</span> idx = 1:length(reps)-1
                        temp_istart = reps(idx) + istart.Z(idx);
                        temp_istop = reps(idx) + istop.Z(idx);
                        temp_df.rep{:,idx} = vel.z(temp_istart:temp_istop);
                    <span class="keyword">end</span>


                    <span class="comment">% concatinate the trimmed repetitions</span>
                    <span class="keyword">for</span> idx = 1:size(temp_df.rep,2)
                        <span class="keyword">if</span> idx == 1
                            concat = temp_df.rep{:,idx};
                            fprintf(<span class="string">'concatinate repetition: %d \n'</span>, idx)
                        <span class="keyword">else</span>
                            concat = cat(1, concat, temp_df.rep{:,idx});
                            fprintf(<span class="string">'concatinate repetition: %d \n'</span>, idx)

                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    figure;
                    plot(concat)
                    nexttile
                    plot(vel.z(reps(1):reps(end)))
</pre><pre class="codeoutput">concatinate repetition: 1 
concatinate repetition: 2 
concatinate repetition: 3 
concatinate repetition: 4 
concatinate repetition: 5 
concatinate repetition: 6 
concatinate repetition: 7 
concatinate repetition: 8 
concatinate repetition: 9 
concatinate repetition: 10 
concatinate repetition: 11 
concatinate repetition: 12 
</pre><img vspace="5" hspace="5" src="MovQualityF_01.png" alt=""> <pre class="codeoutput">concatinate repetition: 1 
concatinate repetition: 2 
concatinate repetition: 3 
concatinate repetition: 4 
concatinate repetition: 5 
concatinate repetition: 6 
concatinate repetition: 7 
concatinate repetition: 8 
concatinate repetition: 9 
concatinate repetition: 10 
concatinate repetition: 11 
concatinate repetition: 12 
</pre><img vspace="5" hspace="5" src="MovQualityF_02.png" alt=""> <img vspace="5" hspace="5" src="MovQualityF_03.png" alt=""> <h2 id="12">4) table stetup and calculati9on of the movement quality parameters</h2><pre class="codeinput">                    ppID    = string(subj_name);
                    trial   = string(fileName);
                    time    = string(Timepoint);
</pre><h2 id="13">4.1) Lyapunov exponent matlab function</h2><pre>DIVERGENCEEXPONENT FUNCTION CALCULATES THE LYAPUNOV EXPONENT
1) it selects the relevant parameters signal and
creates a time axis. 2) it will calculate the power
spectrum to 3) determine the dominant frequency of
the signal. 4) Determines the range over which the
Lyapunov Exponent is calculated (i.e. half a
cycle). 5) reconstructs the number of state spaces
and timelag that fully capture the signal. And
finaly 6) Calculates the Lyapunov Exponent with the
predetermined parameters.</pre><pre class="codeinput">                    [lyapExp_x ,eLag(1), eDim(1)] = DivergenceExponent(acc.x(reps(1):reps(end)), fs);
                    [lyapExp_y, eLag(2), eDim(2)] = DivergenceExponent(acc.y(reps(1):reps(end)), fs);
                    [lyapExp_z, eLag(3), eDim(3)] = DivergenceExponent(acc.z(reps(1):reps(end)), fs);
                    [lyapExp_res, eLag(4), eDim(4)] = DivergenceExponent(acc.res(reps(1):reps(end)), fs);
</pre><pre class="codeoutput">Warning: Integer operands are required for colon operator when used as index. 
Warning: Integer operands are required for colon operator when used as index. 
Warning: Integer operands are required for colon operator when used as index. 
Warning: Integer operands are required for colon operator when used as index. 
</pre><h2 id="15">4.2) LDLJ_A</h2><pre>log_dimensionless_jerk_IMU calculates the smoothness of movement directly from acceleration signals.
Reference:
Melendez-Calderon, A., Shirota, C., &amp; Balasubramanian, S. (2020).
Estimating Movement Smoothness from Inertial Measurement Units.</pre><pre class="codeinput">                    ldlj_a = zeros(1,size(reps,1)-1);

                    <span class="keyword">for</span> idx = 1:size(reps,1)-1
                        t = [reps(idx),reps(idx+1)];
                        ldlj_a(:, idx) = log_dimensionless_jerk_IMU(acc{:,1:3},t, fs);
                    <span class="keyword">end</span>
</pre><h2 id="17">4.3) SPARC --&gt; SPECTRAL ARC LENGTH ON RAW ANGULAR VELOCITY</h2><pre class="codeinput">                    params = [0.05, 20, 4];

                    sparc_x = zeros(1,size(reps,1)-1);
                    sparc_y = zeros(1,size(reps,1)-1);
                    sparc_z = zeros(1,size(reps,1)-1);
                    sparc_res = zeros(1,size(reps,1)-1);

                    <span class="keyword">for</span> idx = 1:size(reps)-1
                        sparc_x(:,idx) = SpectralArcLength(avel.x(reps(idx):reps(idx+1)), fs, params);
                        sparc_y(:,idx) = SpectralArcLength(avel.y(reps(idx):reps(idx+1)), fs, params);
                        sparc_z(:,idx) = SpectralArcLength(avel.z(reps(idx):reps(idx+1)), fs, params);
                        sparc_res(:,idx) = SpectralArcLength(avel.res(reps(idx):reps(idx+1)), fs, params);
                    <span class="keyword">end</span>
</pre><h2 id="18">4.4) sample entropy Jill --&gt; TO defines tollerance</h2><pre>sampen_Jill function calculates the sample entropy
of a signal. Instead of using a signal specific
tollerance as $r = 0.2 * std(signal)$ we calculated
a person specific tollerance based on pre-op
"healthy" data as $r = 0.2 * std(signal_T0)$ . At
the subsequent timepoint that personalised
tollerance is used</pre><pre class="codeinput">                    <span class="comment">% if timepoint == T0, calculate the tollerance and save</span>
                    <span class="comment">% this to file</span>
                    <span class="comment">% if timepoint ~= T0, load the previously saved tollerance</span>

                    <span class="keyword">if</span> strcmp(Timepoint, <span class="string">'T0'</span>)
                        <span class="keyword">if</span> exist(<span class="string">'C:\Users\u0117545\Documents\GitHub\ULIFT_BC\output\tollarance_table.mat'</span>, <span class="string">'file'</span>) == 2
                            load(<span class="string">'C:\Users\u0117545\Documents\GitHub\ULIFT_BC\output\tollarance_table.mat'</span>)
                        <span class="keyword">end</span>

                        sigma = std(acc{reps(1):reps(end), :}, [], 1);
                        r = 0.2 * sigma;
                        m=2;

                        tollarance_table.(arm)(subj, :) = table(ppID, r);


                    <span class="keyword">else</span>
                        m = 2;
                        load <span class="string">C:\Users\u0117545\Documents\GitHub\ULIFT_BC\output\tollarance_table.mat</span>
                        r = tollarance_table.(arm).r(strcmp(tollarance_table.(arm).ppID, subj_name),:);


                    <span class="keyword">end</span>

                    sampen_x = sampen_Jill(acc.x(reps(1):reps(end), :), m, r(1));
                    sampen_y = sampen_Jill(acc.y(reps(1):reps(end), :), m, r(2));
                    sampen_z = sampen_Jill(acc.z(reps(1):reps(end), :), m, r(3));
                    sampen_res = sampen_Jill(acc.res(reps(1):reps(end), :), m, r(4));
</pre><h2 id="20">4.5) Autocorrelation</h2><pre class="codeinput">                    <span class="comment">%-----------------</span>
                    [acorr_x, reg_x] = Symmetry(vel.x(reps(1):reps(end)));
                    [acorr_y, reg_y] = Symmetry(vel.y(reps(1):reps(end)));
                    [acorr_z, reg_z] = Symmetry(vel.z(reps(1):reps(end)));
                    [acorr_res, reg_res] = Symmetry(vel.res(reps(1):reps(end)));
</pre><h2 id="21">4.6) Movement speed based on the repetitions</h2><pre class="codeinput">                    movement_time = zeros(size(reps,1) - 1, 1);
                    <span class="keyword">for</span> idx = 1:size(reps,1) - 1
                        movement_time(idx,1) = 1/fs * (reps(idx+1)-reps(idx));
                    <span class="keyword">end</span>
</pre><h2 id="22">4.7) RMS</h2><p>--&gt; moet in windows!!!! FIX THIS</p><pre class="codeinput">                    rms_x = rms(acc.x(reps(1):reps(end)));
                    rms_y = rms(acc.y(reps(1):reps(end)));
                    rms_z = rms(acc.z(reps(1):reps(end)));
                    rms_res = rms(acc.res(reps(1):reps(end)));

                    rms_T = sqrt(rms_x.^2 + rms_y.^2 + rms_z.^2);

                    rmsr_x = rms_x/rms_T;
                    rmsr_y = rms_y/rms_T;
                    rmsr_z = rms_z/rms_T;
</pre><h2 id="23">5) Save raw acc and avel data to struct</h2><pre class="codeinput">                    <span class="keyword">if</span> strcmp(side, <span class="string">'affected'</span>)
                        MoveQual.raw.affected.(ppID).(Timepoint).(trial).acc = acc(reps(1):reps(end), :);
                        MoveQual.raw.affected.(ppID).(Timepoint).(trial).avel = avel;
                    <span class="keyword">elseif</span> strcmp(side, <span class="string">'unaffected'</span>)
                        MoveQual.raw.unaffected.(ppID).(Timepoint).(trial).acc = acc;
                        MoveQual.raw.unaffected.(ppID).(Timepoint).(trial).avel = acc;
                    <span class="keyword">end</span>
</pre><h2 id="24">6) Save movement quality to table</h2><pre class="codeinput">                    <span class="keyword">if</span> strcmp(side, <span class="string">'affected'</span>)
                        aff.key(subj,:) = table(ppID, trial,time);

                        <span class="comment">%stability || lyapunov exponent</span>
                        aff.lyapExp(subj,:) = table(ppID, lyapExp_x, lyapExp_y, lyapExp_z, lyapExp_res);


                        <span class="comment">%predictability || Sample Entropy</span>
                        aff.Entropy_aff(subj,:) = table(ppID, sampen_x, sampen_y, sampen_z, sampen_res);


                        <span class="comment">%movement time || average</span>
                        aff.avg_move_time_aff(subj,:) = table(ppID, mean(movement_time));
                        aff.avg_move_time_aff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'avg_movement_time'</span>};

                        <span class="comment">%movement time || variability</span>
                        aff.var_move_time_aff(subj,:) = table(ppID, std(movement_time));
                        aff.var_move_time_aff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'var_movement_time'</span>};

                        <span class="comment">%regularity || autocorrelation</span>
                        aff.regularity(subj,:) = table(ppID, reg_x, reg_y, reg_z, reg_res);

                        <span class="comment">%variability || root mean square</span>
                        aff.RMS_x(subj,:) = table(ppID, rms_x, rms_y, rms_z, rms_res);

                        <span class="comment">%variability || root mean square ratio</span>
                        aff.RMSR_x(subj,:) = table(ppID, rmsr_x, rmsr_y, rmsr_z);

                        <span class="comment">%smoothness || SPARC</span>
                        aff.SPARC_aff(subj,:) = table(ppID, mean(sparc_x), mean(sparc_y), mean(sparc_z), mean(sparc_res));
                        aff.SPARC_aff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'sparc_x'</span>, <span class="string">'sparc_y'</span>, <span class="string">'sparc_z'</span>, <span class="string">'sparc_res'</span>};

                        <span class="comment">%smoothness || LDLJ</span>
                        aff.LDLJ_A_aff (subj, :) = table(ppID, mean(ldlj_a));
                        aff.LDLJ_A_aff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'LDLJ_A'</span>};

                    <span class="keyword">elseif</span> strcmp(side, <span class="string">'unaffected'</span>)
                        unaff.key(subj,:) = table(ppID, trial, time);

                        <span class="comment">%stability || lyapunov exponent</span>
                        unaff.lyapExp(subj,:) = table(ppID, lyapExp_x, lyapExp_y, lyapExp_z, lyapExp_res);

                        <span class="comment">%predictability || sample entropy</span>
                        unaff.Entropy_unaff(subj,:) = table(ppID, sampen_x, sampen_y, sampen_z, sampen_res);

                        <span class="comment">%movement time || average</span>
                        unaff.avg_move_time_unaff(subj,:) = table(ppID, mean(movement_time));
                        unaff.avg_move_time_unaff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'avg_movement_time'</span>};

                        <span class="comment">%movement time || varibility</span>
                        unaff.var_move_time_unaff(subj,:) = table(ppID, std(movement_time));
                        unaff.var_move_time_unaff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'var_movement_time'</span>};

                        <span class="comment">%regularity || autocorrelation</span>
                        unaff.regularity_x(subj,:) = table(ppID, reg_x, reg_y, reg_z, reg_res);

                        <span class="comment">%variability || root mean square</span>
                        unaff.RMS_x(subj,:) = table(ppID, rms_x, rms_y, rms_z, rms_res);

                        <span class="comment">%variability || root mean square ratio</span>
                        unaff.RMSR_x(subj,:) = table(ppID, rmsr_x, rmsr_y, rmsr_z);

                        <span class="comment">%smoothness || SPARC</span>
                        unaff.SPARC_unaff(subj,:) = table(ppID, mean(sparc_x), mean(sparc_y), mean(sparc_z), mean(sparc_res));
                        unaff.SPARC_unaff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'sparc_x'</span>, <span class="string">'sparc_y'</span>, <span class="string">'sparc_z'</span>, <span class="string">'sparc_res'</span>};

                        <span class="comment">%smoothness ||LDLJ</span>
                        unaff.LDLJ_A_unaff(subj, :) = table(ppID, mean(ldlj_a));
                        unaff.LDLJ_A_unaff.Properties.VariableNames = {<span class="string">'ppID'</span>, <span class="string">'LDLJ_A'</span>};

                    <span class="keyword">end</span>
</pre><pre class="codeinput">                <span class="keyword">end</span><span class="comment">% if information about the affected side is availible</span>
            <span class="keyword">end</span><span class="comment">% file name contains movement and .mvnx</span>
        <span class="keyword">end</span><span class="comment">% loop though the number of files</span>
    <span class="keyword">end</span><span class="comment">% check if data folder exists</span>
<span class="keyword">end</span><span class="comment">% loop through number of subjects</span>
</pre><pre class="codeoutput"> 
Processing BC_006: T0.....
</pre><h2 id="26">7) everything in one gigantic table.</h2><p>every timepoint has an individual tab unaffected</p><pre class="codeinput">fields = fieldnames(unaff);
MovementQual.unaff = rmmissing(unaff.key);
<span class="keyword">for</span> fld = 2:size(fields, 1)
    MovementQual.unaff = join(MovementQual.unaff, unaff.(fields{fld}));
<span class="keyword">end</span>

clear <span class="string">fields</span> <span class="string">fld</span>

<span class="comment">%affected</span>
fields = fieldnames(aff);
MovementQual.aff = rmmissing(aff.key);
<span class="keyword">for</span> fld = 1:size(fields,1)
    MovementQual.aff = join(MovementQual.aff, aff.(fields{fld}));
<span class="keyword">end</span>

clear <span class="string">fields</span> <span class="string">fld</span>


writetable(MovementQual.unaff,<span class="string">'C:\Users\u0117545\Documents\GitHub\ULIFT_BC\Output\MoveQual_unaff.xlsx'</span>, <span class="string">'FileType'</span>, <span class="string">'spreadsheet'</span>,  <span class="keyword">...</span>
    <span class="string">"WriteMode"</span>, <span class="string">"append"</span>, <span class="string">"Sheet"</span>, Timepoint)

writetable(MovementQual.aff, <span class="string">'C:\Users\u0117545\Documents\GitHub\ULIFT_BC\Output\MoveQual_aff.xlsx'</span>, <span class="string">'FileType'</span>, <span class="string">'spreadsheet'</span>, <span class="keyword">...</span>
    <span class="string">'WriteMode'</span>, <span class="string">'append'</span>, <span class="string">'sheet'</span>, Timepoint)

save(<span class="string">'C:\Users\u0117545\Documents\GitHub\ULIFT_BC\Output\tollarance_table.mat'</span>,<span class="string">'tollarance_table'</span>)
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% movement quality functional activity
%
%  TO DO
%  selecteer de "rust fases" voor en na de gesegmenteerde herhalingen en
%  verwijder deze. Plak daarna de signalen weer aan elkaar.
%

%%
%
%  I need to run this file using publish en use that as a help function.
%  Which means I need to explain everyting in more detail. When the code is
%  finished :)
%


%%
% 
%  BC_014 T2 REPLACE_WITH_DASH_DASH> heeft veel last. Dus misschien interessant om die data te
%  bekijken. 
% 


clearvars; clc; close all;
%% 1) Input
%%
%
%  Change the U-number and path to match where the data is located. Change
%  the timepoint that you want to analyse

cd("C:\Users\u0117545\Documents\GitHub\ULIFT_BC")
addpath("C:\Users\u0117545\OneDrive - KU Leuven\2.Dataprocessing\Matlab\addons")

Timepoint   = 'T0';
movement    = "F";
path.root   = 'C:\Users\u0117545\KU Leuven\An De Groef - DATA';
path.out    = fullfile(path.root,'Output','Database_MovQual.mat');
fs          = 60;
plot_or_not = 1;

Affected_table = readtable(fullfile(path.root,"Aangedane zijde.xlsx"));

%% 2) Load data
for subj = (6)% 9 10 11 12 14 16 17 19 21)  % 1:21%21 (8 9 10 11 12 14 16 17 19 21) == proefpersonen zonder "rust" data.
    if subj < 10
        subj_name   = ['BC_00' num2str(subj)];
    elseif subj < 100
        subj_name   = ['BC_0' num2str(subj)];
    else
        subj_name   = ['BC_', num2str(subj)];
    end

    affected = Affected_table(strcmp(Affected_table.ppID, subj_name), "involved");


    disp(' ')
    disp(['Processing ' subj_name ': ' Timepoint '.....'])

    path.subj   = fullfile(path.root, subj_name, 'Xsens', Timepoint, 'Reproces');
    check_subj  = exist(path.subj, "dir");

    if check_subj == 7
        %initialize counters
        counterR        = 0;
        counterR_SSS    = 0;
        counterL        = 0;
        counterL_SSS    = 0;

        content = dir(path.subj);
        nfiles = size(content,1);

        % Start loop through ULIFT files per subject
        for file = 1:nfiles
            if contains(content(file).name, movement) && contains(content(file).name, '.mvnx') && ~contains(content(file).name, 'AF') && ~contains(content(file).name, 'ULIFT')
                file_ik = fullfile(path.subj, content(file).name);

                [~,name, ~] = fileparts(content(file).name);
                [fileName] = regexprep(name, '-', '_');

                d = strfind(name,'_');
                arm = content(file).name(d+1);

                if ~isempty(Affected_table{strcmp(Affected_table.ppID, subj_name), "involved"})
                    if strcmp(arm, 'L')
                        sensorno    = 10;
                        segmentno   = 14;
                        jointno     = 12;

                        if strcmp(Affected_table{strcmp(Affected_table.ppID, subj_name), "involved"}, 'L')
                            side = 'affected';
                        else
                            side = 'unaffected';

                        end

                    elseif strcmp(arm, 'R')
                        sensorno    = 6;
                        segmentno   = 10;
                        jointno     = 8;

                        if strcmp(Affected_table{strcmp(Affected_table.ppID, subj_name), "involved"}, 'R')
                            side = 'affected';
                        else
                            side = 'unaffected';
                        end
                    end

                    disp(['     ' 'Analysing: ' fileName '.....'])
                    disp(['   ' 'Arm of interst: ' arm '.....'])


                    %% 2.1) Load xsens data
                    % Change the filename here to the name of the file you would like to import
                    disp(['    ' content(file).name ': read xsens file'])
                    [sensorData, segmentData, jointData]= MVN(file_ik);

                    % extract unflitered acceleration data
                    x = sensorData(sensorno).sensorFreeAcceleration(:,1);
                    y = sensorData(sensorno).sensorFreeAcceleration(:,2);
                    z = sensorData(sensorno).sensorFreeAcceleration(:,3);
                    res = vecnorm(sensorData(sensorno).sensorFreeAcceleration,2,2);
                    acc = table(x, y, z, res); % table of unfiltered acceleration data
                    clear x y z res


                    % extract unfiltered angular velocity data
                    x = segmentData(segmentno).angularVelocity(:,1);
                    y = segmentData(segmentno).angularVelocity(:,2);
                    z = segmentData(segmentno).angularVelocity(:,3);
                    res = vecnorm(segmentData(segmentno).angularVelocity,2,2);

                    avel = table(x, y, z, res);
                    clear x y z res

                    % extract unfiltered sement velocity data
                    x = segmentData(segmentno).velocity(:,1);
                    y = segmentData(segmentno).velocity(:,2);
                    z = segmentData(segmentno).velocity(:,3);
                    res = vecnorm(segmentData(segmentno).velocity, 2, 2);

                    vel = table(x, y, z, res);
                    clear x y z res

                    %% 3) Event detection
                    %%
                    %
                    %  Seperation of the different repetitions using
                    %  filtered velocity data. Filter properties: 4th
                    %  order Butterwoth filter at 2 Hz. Peak detection of local maxima and minima is
                    %  applied on the velocity vector. 
                    %  Local minimaREPLACE_WITH_DASH_DASH vector approximates zeroREPLACE_WITH_DASH_DASH means a
                    %  change in direction. We use a priori knowledge that
                    %  the the first rep should start after a local
                    %  maximum. This to remove the first and last
                    %  initiation where the intentd of movement is
                    %  different.
                    %

                    disp(['    ' content(file).name ': define seperate repetitions'])

                    %filtered velocity data for segmentation
                    fc = 2;  %cutoff freq
                    fs = 60; %sample freq
                    [b,a] = butter(4, fc/(fs/2));

                    velocity2 = filtfilt(b,a, segmentData(segmentno).velocity);
                    velocityX = velocity2(:,1);
                    velocityY = velocity2(:,2);
                    velocityZ = velocity2(:,3);
                    velocityVec = vecnorm(velocity2, 2,2);

                    vel_filtered     = table(velocityX, velocityY, velocityZ, velocityVec);

                    clear velocity2 velocityX velocityY velocityZ velocityVec
              
                    [peakLocMax, peakMagMax] =  peakfinder(vel_filtered.velocityVec, [],[],1, false);
                    [peakLocMin, peakMagMin] =  peakfinder(vel_filtered.velocityVec, [],[],-1, false);

                    if strcmp(side, 'affected')
                        if peakLocMin(1) - peakLocMax(1) < 0
                            startpeak = 2;
                            reps = peakLocMin(startpeak:2:end);
                        elseif peakLocMin(1) - peakLocMax(1) > 0
                            startpeak = 1;
                            reps = peakLocMin(startpeak:2:end);
                        end
                    end

                    if peakLocMin(1) - peakLocMax(1) < 0
                        reps = peakLocMin(2:2:end);
                    elseif peakLocMin(1) - peakLocMax(1) > 0
                        reps = peakLocMin(1:2:end);
                    end

                    %% 3.1) excessive "rest" periods
                    %%
                    % 
                    %  Extensive rest periods in the data influence the
                    %  calculation of the movement qality parameters.
                    %  Therefore we need to remove those rest periods and
                    %  only retain the moving data.
                    %   
                    %  THE DATA IS COMPARED TO A REFERENCE SIGNAL.
                    %  IN THIS CASE A SIMPLE INVERTED SINE WAVE in case of
                    %  the velocity in z-rection 
                    %  We use the rationalle that we only want to calculate
                    %  the movement quality parameters on movement data.
                    %  Therefore, we are strickt in our trimming process,
                    %  and use the velocity data in Z-direction in stead of the vector. 


                    t=0:0.001:1;
                    f=1;
                    x=sin(2*pi*f*t)*-1;

                    for idx = 1:length(reps)-1
                        [istart.Z(idx),istop.Z(idx),dist.Z(idx)] = findsignal(vel_filtered.velocityZ(reps(idx):reps(idx+1)), x,'TimeAlignment','dtw','Metric','absolute');
                    end

                    %plot individual velocity vectors
                    if plot_or_not
                        if strcmp(side, 'affected')
                            nexttile
                            for idx = 1:length(reps)-1
                                plot(vel.z(reps(idx):reps(idx+1)))
                                hold on;
                                hline(0)
                            end
                            plottitle = {[subj_name, ' individual reps']};
                            title(plottitle)

                            nexttile
                            for idx = 1:length(reps)-1
                                temp_istart = reps(idx) + istart.Z(idx);
                                temp_istop = reps(idx) + istop.Z(idx);
                                temp_df.rep{:,idx} = vel.z(temp_istart:temp_istop);


                                plot(temp_df.rep{:,idx}); hold on
                            end
                            plottitle = {[subj_name, ' individual reps trimmed']};
                            title(plottitle)
                        end
                    end


                    % trim the repetitions and save them in a temporary
                    % variable.
                    for idx = 1:length(reps)-1
                        temp_istart = reps(idx) + istart.Z(idx);
                        temp_istop = reps(idx) + istop.Z(idx);
                        temp_df.rep{:,idx} = vel.z(temp_istart:temp_istop);  
                    end


                    % concatinate the trimmed repetitions
                    for idx = 1:size(temp_df.rep,2)
                        if idx == 1
                            concat = temp_df.rep{:,idx};
                            fprintf('concatinate repetition: %d \n', idx)
                        else
                            concat = cat(1, concat, temp_df.rep{:,idx});
                            fprintf('concatinate repetition: %d \n', idx)

                        end
                    end
                    figure;
                    plot(concat)
                    nexttile 
                    plot(vel.z(reps(1):reps(end)))
                    %% 4) table stetup and calculati9on of the movement quality parameters
                    ppID    = string(subj_name);
                    trial   = string(fileName);
                    time    = string(Timepoint);

                    %% 4.1) Lyapunov exponent matlab function
                    

                    %%
                    % 
                    %  DIVERGENCEEXPONENT FUNCTION CALCULATES THE LYAPUNOV EXPONENT
                    %  1) it selects the relevant parameters signal and
                    %  creates a time axis. 2) it will calculate the power
                    %  spectrum to 3) determine the dominant frequency of
                    %  the signal. 4) Determines the range over which the
                    %  Lyapunov Exponent is calculated (i.e. half a
                    %  cycle). 5) reconstructs the number of state spaces
                    %  and timelag that fully capture the signal. And
                    %  finaly 6) Calculates the Lyapunov Exponent with the
                    %  predetermined parameters.
                    % 
             
                    [lyapExp_x ,eLag(1), eDim(1)] = DivergenceExponent(acc.x(reps(1):reps(end)), fs);
                    [lyapExp_y, eLag(2), eDim(2)] = DivergenceExponent(acc.y(reps(1):reps(end)), fs);
                    [lyapExp_z, eLag(3), eDim(3)] = DivergenceExponent(acc.z(reps(1):reps(end)), fs);
                    [lyapExp_res, eLag(4), eDim(4)] = DivergenceExponent(acc.res(reps(1):reps(end)), fs);


                    %% 4.2) LDLJ_A

                    %%
                    %
                    %  log_dimensionless_jerk_IMU calculates the smoothness of movement directly from acceleration signals.
                    %  Reference:
                    %  Melendez-Calderon, A., Shirota, C., & Balasubramanian, S. (2020).
                    %  Estimating Movement Smoothness from Inertial Measurement Units.
                    %

                    ldlj_a = zeros(1,size(reps,1)-1);

                    for idx = 1:size(reps,1)-1
                        t = [reps(idx),reps(idx+1)];
                        ldlj_a(:, idx) = log_dimensionless_jerk_IMU(acc{:,1:3},t, fs);
                    end

                    %% 4.3) SPARC REPLACE_WITH_DASH_DASH> SPECTRAL ARC LENGTH ON RAW ANGULAR VELOCITY
                    params = [0.05, 20, 4];

                    sparc_x = zeros(1,size(reps,1)-1);
                    sparc_y = zeros(1,size(reps,1)-1);
                    sparc_z = zeros(1,size(reps,1)-1);
                    sparc_res = zeros(1,size(reps,1)-1);

                    for idx = 1:size(reps)-1
                        sparc_x(:,idx) = SpectralArcLength(avel.x(reps(idx):reps(idx+1)), fs, params);
                        sparc_y(:,idx) = SpectralArcLength(avel.y(reps(idx):reps(idx+1)), fs, params);
                        sparc_z(:,idx) = SpectralArcLength(avel.z(reps(idx):reps(idx+1)), fs, params);
                        sparc_res(:,idx) = SpectralArcLength(avel.res(reps(idx):reps(idx+1)), fs, params);
                    end


                    %% 4.4) sample entropy Jill REPLACE_WITH_DASH_DASH> TO defines tollerance

                    %%
                    %
                    %  sampen_Jill function calculates the sample entropy
                    %  of a signal. Instead of using a signal specific
                    %  tollerance as $r = 0.2 * std(signal)$ we calculated
                    %  a person specific tollerance based on pre-op
                    %  "healthy" data as $r = 0.2 * std(signal_T0)$ . At
                    %  the subsequent timepoint that personalised
                    %  tollerance is used
                    %

                    % if timepoint == T0, calculate the tollerance and save
                    % this to file
                    % if timepoint ~= T0, load the previously saved tollerance

                    if strcmp(Timepoint, 'T0')
                        if exist('C:\Users\u0117545\Documents\GitHub\ULIFT_BC\output\tollarance_table.mat', 'file') == 2
                            load('C:\Users\u0117545\Documents\GitHub\ULIFT_BC\output\tollarance_table.mat')
                        end

                        sigma = std(acc{reps(1):reps(end), :}, [], 1);
                        r = 0.2 * sigma;
                        m=2;

                        tollarance_table.(arm)(subj, :) = table(ppID, r);

             
                    else
                        m = 2;
                        load C:\Users\u0117545\Documents\GitHub\ULIFT_BC\output\tollarance_table.mat
                        r = tollarance_table.(arm).r(strcmp(tollarance_table.(arm).ppID, subj_name),:);


                    end

                    sampen_x = sampen_Jill(acc.x(reps(1):reps(end), :), m, r(1));
                    sampen_y = sampen_Jill(acc.y(reps(1):reps(end), :), m, r(2));
                    sampen_z = sampen_Jill(acc.z(reps(1):reps(end), :), m, r(3));
                    sampen_res = sampen_Jill(acc.res(reps(1):reps(end), :), m, r(4));

                    %% 4.5) Autocorrelation
                    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
                    [acorr_x, reg_x] = Symmetry(vel.x(reps(1):reps(end)));
                    [acorr_y, reg_y] = Symmetry(vel.y(reps(1):reps(end)));
                    [acorr_z, reg_z] = Symmetry(vel.z(reps(1):reps(end)));
                    [acorr_res, reg_res] = Symmetry(vel.res(reps(1):reps(end)));

                    %% 4.6) Movement speed based on the repetitions
                    movement_time = zeros(size(reps,1) - 1, 1);
                    for idx = 1:size(reps,1) - 1
                        movement_time(idx,1) = 1/fs * (reps(idx+1)-reps(idx));
                    end

                    %% 4.7) RMS
                    % REPLACE_WITH_DASH_DASH> moet in windows!!!! FIX THIS
                    rms_x = rms(acc.x(reps(1):reps(end)));
                    rms_y = rms(acc.y(reps(1):reps(end)));
                    rms_z = rms(acc.z(reps(1):reps(end)));
                    rms_res = rms(acc.res(reps(1):reps(end)));

                    rms_T = sqrt(rms_x.^2 + rms_y.^2 + rms_z.^2);

                    rmsr_x = rms_x/rms_T;
                    rmsr_y = rms_y/rms_T;
                    rmsr_z = rms_z/rms_T;

                    %% 5) Save raw acc and avel data to struct
                    if strcmp(side, 'affected')
                        MoveQual.raw.affected.(ppID).(Timepoint).(trial).acc = acc(reps(1):reps(end), :);
                        MoveQual.raw.affected.(ppID).(Timepoint).(trial).avel = avel;
                    elseif strcmp(side, 'unaffected')
                        MoveQual.raw.unaffected.(ppID).(Timepoint).(trial).acc = acc;
                        MoveQual.raw.unaffected.(ppID).(Timepoint).(trial).avel = acc;
                    end

                    %% 6) Save movement quality to table
                    if strcmp(side, 'affected')
                        aff.key(subj,:) = table(ppID, trial,time);

                        %stability || lyapunov exponent
                        aff.lyapExp(subj,:) = table(ppID, lyapExp_x, lyapExp_y, lyapExp_z, lyapExp_res);


                        %predictability || Sample Entropy
                        aff.Entropy_aff(subj,:) = table(ppID, sampen_x, sampen_y, sampen_z, sampen_res);


                        %movement time || average
                        aff.avg_move_time_aff(subj,:) = table(ppID, mean(movement_time));
                        aff.avg_move_time_aff.Properties.VariableNames = {'ppID', 'avg_movement_time'};

                        %movement time || variability
                        aff.var_move_time_aff(subj,:) = table(ppID, std(movement_time));
                        aff.var_move_time_aff.Properties.VariableNames = {'ppID', 'var_movement_time'};

                        %regularity || autocorrelation
                        aff.regularity(subj,:) = table(ppID, reg_x, reg_y, reg_z, reg_res);

                        %variability || root mean square
                        aff.RMS_x(subj,:) = table(ppID, rms_x, rms_y, rms_z, rms_res);

                        %variability || root mean square ratio
                        aff.RMSR_x(subj,:) = table(ppID, rmsr_x, rmsr_y, rmsr_z);

                        %smoothness || SPARC
                        aff.SPARC_aff(subj,:) = table(ppID, mean(sparc_x), mean(sparc_y), mean(sparc_z), mean(sparc_res));
                        aff.SPARC_aff.Properties.VariableNames = {'ppID', 'sparc_x', 'sparc_y', 'sparc_z', 'sparc_res'};

                        %smoothness || LDLJ
                        aff.LDLJ_A_aff (subj, :) = table(ppID, mean(ldlj_a));
                        aff.LDLJ_A_aff.Properties.VariableNames = {'ppID', 'LDLJ_A'};

                    elseif strcmp(side, 'unaffected')
                        unaff.key(subj,:) = table(ppID, trial, time);

                        %stability || lyapunov exponent
                        unaff.lyapExp(subj,:) = table(ppID, lyapExp_x, lyapExp_y, lyapExp_z, lyapExp_res);

                        %predictability || sample entropy
                        unaff.Entropy_unaff(subj,:) = table(ppID, sampen_x, sampen_y, sampen_z, sampen_res);

                        %movement time || average
                        unaff.avg_move_time_unaff(subj,:) = table(ppID, mean(movement_time));
                        unaff.avg_move_time_unaff.Properties.VariableNames = {'ppID', 'avg_movement_time'};

                        %movement time || varibility
                        unaff.var_move_time_unaff(subj,:) = table(ppID, std(movement_time));
                        unaff.var_move_time_unaff.Properties.VariableNames = {'ppID', 'var_movement_time'};

                        %regularity || autocorrelation
                        unaff.regularity_x(subj,:) = table(ppID, reg_x, reg_y, reg_z, reg_res);

                        %variability || root mean square
                        unaff.RMS_x(subj,:) = table(ppID, rms_x, rms_y, rms_z, rms_res);

                        %variability || root mean square ratio
                        unaff.RMSR_x(subj,:) = table(ppID, rmsr_x, rmsr_y, rmsr_z);

                        %smoothness || SPARC
                        unaff.SPARC_unaff(subj,:) = table(ppID, mean(sparc_x), mean(sparc_y), mean(sparc_z), mean(sparc_res));
                        unaff.SPARC_unaff.Properties.VariableNames = {'ppID', 'sparc_x', 'sparc_y', 'sparc_z', 'sparc_res'};

                        %smoothness ||LDLJ
                        unaff.LDLJ_A_unaff(subj, :) = table(ppID, mean(ldlj_a));
                        unaff.LDLJ_A_unaff.Properties.VariableNames = {'ppID', 'LDLJ_A'};

                    end
                end% if information about the affected side is availible
            end% file name contains movement and .mvnx
        end% loop though the number of files
    end% check if data folder exists
end% loop through number of subjects



%% 7) everything in one gigantic table.
% every timepoint has an individual tab
% unaffected
fields = fieldnames(unaff);
MovementQual.unaff = rmmissing(unaff.key);
for fld = 2:size(fields, 1)
    MovementQual.unaff = join(MovementQual.unaff, unaff.(fields{fld}));
end

clear fields fld

%affected
fields = fieldnames(aff);
MovementQual.aff = rmmissing(aff.key);
for fld = 1:size(fields,1)
    MovementQual.aff = join(MovementQual.aff, aff.(fields{fld}));
end

clear fields fld


writetable(MovementQual.unaff,'C:\Users\u0117545\Documents\GitHub\ULIFT_BC\Output\MoveQual_unaff.xlsx', 'FileType', 'spreadsheet',  ...
    "WriteMode", "append", "Sheet", Timepoint)

writetable(MovementQual.aff, 'C:\Users\u0117545\Documents\GitHub\ULIFT_BC\Output\MoveQual_aff.xlsx', 'FileType', 'spreadsheet', ...
    'WriteMode', 'append', 'sheet', Timepoint)

save('C:\Users\u0117545\Documents\GitHub\ULIFT_BC\Output\tollarance_table.mat','tollarance_table')


##### SOURCE END #####
--></body></html>